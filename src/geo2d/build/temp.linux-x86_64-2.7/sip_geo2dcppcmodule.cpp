/*
 * Module code.
 *
 * Generated by SIP 4.10.2 on Thu Mar 12 16:30:15 2015
 */

#include "sipAPI_geo2dcpp.h"

#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 12 "sip_geo2dcppcmodule.cpp"
#line 288 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 15 "sip_geo2dcppcmodule.cpp"
#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 18 "sip_geo2dcppcmodule.cpp"
#line 127 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 21 "sip_geo2dcppcmodule.cpp"
#line 208 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 24 "sip_geo2dcppcmodule.cpp"
#line 122 "sip/stlextra.sip"
#include <vector>
#line 27 "sip_geo2dcppcmodule.cpp"
#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 30 "sip_geo2dcppcmodule.cpp"
#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 33 "sip_geo2dcppcmodule.cpp"
#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 36 "sip_geo2dcppcmodule.cpp"
#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 39 "sip_geo2dcppcmodule.cpp"
#line 736 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 42 "sip_geo2dcppcmodule.cpp"
#line 14 "/home/rbianchi/projects/draw_areas/src/sipbin/stl.sip"
#include <vector>
#line 45 "sip_geo2dcppcmodule.cpp"
#line 368 "sip/stlextra.sip"
#include <map>
#include <stdio.h>
#line 49 "sip_geo2dcppcmodule.cpp"

/* Define the strings used by this module. */
const char sipStrings__geo2dcpp[] = {
    's', 't', 'd', ':', ':', 'm', 'a', 'p', '<', 'd', 'o', 'u', 'b', 'l', 'e', ',', 's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', 'a', 't', 'h', '2', 'd', '>', ' ', '>', 0,
    's', 't', 'd', ':', ':', 'm', 'a', 'p', '<', 'i', 'n', 't', ',', 's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', 'a', 't', 'h', '2', 'd', '>', ' ', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', 'a', 't', 'h', '2', 'd', '>', ' ', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'd', 'o', 'u', 'b', 'l', 'e', '>', ' ', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', '2', 'd', '>', ' ', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'Q', 'u', 'a', 'l', 'i', 't', 'y', 'M', 'a', 'r', 'k', 'e', 'r', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'u', 'n', 's', 'i', 'g', 'n', 'e', 'd', ' ', 'c', 'h', 'a', 'r', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'm', 'a', 't', 'c', 'h', '_', 'r', 'e', 's', 'u', 'l', 't', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'c', 'o', 'v', 'e', 'r', 'i', 'n', 'g', 'R', 'e', 'c', 't', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'O', 'r', 'i', 'e', 'n', 't', 'e', 'd', 'B', 'B', '*', '>', 0,
    'M', 'L', 'B', 'S', 'p', 'l', 'i', 'n', 'e', 'I', 'n', 't', 'e', 'r', 'p', 'o', 'l', 'a', 't', 'o', 'r', 0,
    'c', 'o', 'n', 'v', 'e', 'x', '_', 'h', 'u', 'l', 'l', '_', 'p', 'r', 'e', 's', 'o', 'r', 't', 'e', 'd', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', 'a', 'c', 'k', 'i', 'n', 'g', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'D', 'e', 'f', 'e', 'c', 't', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', 'a', 't', 'h', '2', 'd', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'd', 'o', 'u', 'b', 'l', 'e', '>', 0,
    'v', 'e', 'c', 'p', 'a', 't', 'h', 'O', 'v', 'e', 'r', 'V', 'e', 'c', 'p', 'a', 't', 'h', 0,
    's', 'e', 'l', 'f', '_', 'i', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 'i', 'o', 'n', 's', 0,
    's', 'i', 'm', 'p', 'l', 'i', 'f', 'y', '_', 'c', 'o', 'n', 't', 'a', 'i', 'n', 'e', 'd', 0,
    'q', 'u', 'a', 's', 'i', '_', 'c', 'o', 'n', 'v', 'e', 'x', '_', 'h', 'u', 'l', 'l', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'b', 'o', 'o', 'l', '>', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'P', '2', 'd', '>', 0,
    'u', 'n', 'i', 'f', 'o', 'r', 'm', '_', 's', 'a', 'm', 'p', 'l', 'i', 'n', 'g', 0,
    'P', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ':', ':', 'S', 'h', 'e', 'e', 't', 0,
    'P', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ':', ':', 'S', 'h', 'a', 'p', 'e', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'i', 'n', 't', '>', 0,
    'v', 'e', 'c', 'v', 'e', 'c', 'p', 'a', 't', 'h', '_', 't', 'e', 's', 't', 0,
    'm', 'a', 'p', 'v', 'e', 'c', 'p', 'a', 't', 'h', '_', 't', 'e', 's', 't', 0,
    'v', 'e', 'c', 'p', 'a', 't', 'h', 'O', 'v', 'e', 'r', 'P', 'a', 't', 'h', 0,
    'p', 'o', 'i', 'n', 't', 's', '_', 'm', 'a', 't', 'c', 'h', 'i', 'n', 'g', 0,
    'c', 'o', 'm', 'p', 'l', 'e', 'x', 'S', 'p', 'l', 'i', 'n', 'e', 'X', 'C', 0,
    'P', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ':', ':', 'P', 'a', 'r', 't', 0,
    'g', 'e', 't', '_', 'a', 'l', 'l', 'o', 'c', '_', 'c', 'o', 'u', 'n', 't', 0,
    'g', 'e', 'o', '2', 'd', '.', '_', 'g', 'e', 'o', '2', 'd', 'c', 'p', 'p', 0,
    'f', 'i', 'x', 'e', 'd', '_', 's', 'a', 'm', 'p', 'l', 'i', 'n', 'g', 0,
    'u', 'n', 'i', 'o', 'n', 'A', 'r', 'e', 'a', 'V', 'a', 'l', 'u', 'e', 0,
    'u', 'n', 'i', 'o', 'n', 'A', 'r', 'e', 'a', 'P', 'a', 't', 'h', 's', 0,
    'Q', 'u', 'a', 'l', 'i', 't', 'y', 'M', 'a', 'r', 'k', 'e', 'r', 0,
    'm', 'o', 's', 't', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'P', 0,
    'R', 'u', 'n', 't', 'i', 'm', 'e', 'E', 'r', 'r', 'o', 'r', 0,
    'm', 'a', 't', 'c', 'h', '_', 'r', 'e', 's', 'u', 'l', 't', 0,
    'c', 'o', 'v', 'e', 'r', 'i', 'n', 'g', 'R', 'e', 'c', 't', 0,
    'b', 'u', 'm', 'p', ':', ':', 'B', 'u', 'm', 'p', 'e', 'r', 0,
    'b', 'u', 'm', 'p', ':', ':', 'P', 'o', 's', 'R', 'o', 't', 0,
    'I', 'n', 's', 'i', 'd', 'e', 'T', 'e', 's', 't', 'e', 'r', 0,
    'i', 'n', 's', 'i', 'd', 'e', '_', 'e', 'q', 'u', 'a', 'l', 0,
    'e', 'n', 'l', 'a', 'r', 'g', 'e', '_', 'a', 'r', 'e', 'a', 0,
    'p', 'a', 'r', 'a', '_', 's', 'm', 'u', 's', 's', 'a', 'f', 0,
    'p', 'a', 't', 'h', 'P', 'a', 't', 'h', 'D', 'i', 's', 't', 0,
    't', 'r', 'i', 'a', 'n', 'g', 'l', 'e', 'A', 'r', 'e', 'a', 0,
    's', 't', 'd', ':', ':', 'w', 's', 't', 'r', 'i', 'n', 'g', 0,
    'g', 'e', 't', '_', 'w', 'e', 'i', 'g', 'h', 't', 's', 0,
    'r', 'e', 'c', 't', 's', '_', 'c', 'o', 'v', 'e', 'r', 0,
    'u', 'n', 'i', 'o', 'n', 'e', '_', 'p', 'a', 't', 'h', 0,
    'b', 'u', 'm', 'p', ':', ':', 'S', 'h', 'a', 'p', 'e', 0,
    't', 'r', 'i', 'a', 'n', 'g', 'u', 'l', 'a', 't', 'e', 0,
    'b', 'o', 'u', 'n', 'd', 'i', 'n', 'g', 'B', 'o', 'x', 0,
    '_', '_', 'g', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    's', 't', 'd', ':', ':', 's', 't', 'r', 'i', 'n', 'g', 0,
    'B', 'l', 'o', 'c', 'k', 's', 'I', 'n', 'f', 'o', 0,
    'O', 'r', 'i', 'e', 'n', 't', 'e', 'd', 'B', 'B', 0,
    'o', 'l', 'd', 'S', 'p', 'l', 'i', 'n', 'e', 'X', 0,
    's', 'e', 't', 'H', 'b', 'o', 'r', 'd', 'e', 'r', 0,
    'g', 'e', 't', 'H', 'b', 'o', 'r', 'd', 'e', 'r', 0,
    'r', 'e', 'g', 'u', 'l', 'a', 'r', 'i', 'z', 'e', 0,
    'f', 'r', 'o', 'm', 's', 't', 'r', 'i', 'n', 'g', 0,
    'i', 's', 'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 0,
    'b', 'e', 's', 't', 'A', 'n', 'g', 'l', 'e', 0,
    'M', 'i', 'n', 'i', 'm', 'u', 'm', 'B', 'B', 0,
    'i', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 0,
    'P', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', 0,
    's', 'i', 'm', 'p', 'l', 'i', 'f', 'y', 'f', 0,
    's', 'm', 'o', 'o', 't', 'h', '1', '2', '1', 0,
    'a', 'd', 'd', 'P', 'o', 'i', 'n', 't', 0,
    '_', '_', 'i', 'd', 'i', 'v', '_', '_', 0,
    '_', '_', 'i', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'i', 'a', 'd', 'd', '_', '_', 0,
    'N', 'D', 'V', 'e', 'c', 't', 'o', 'r', 0,
    'g', 'e', 't', 'A', 'n', 'g', 'l', 'e', 0,
    '_', '_', 'i', 'm', 'u', 'l', '_', '_', 0,
    'c', 'o', 'n', 't', 'a', 'i', 'n', 's', 0,
    'c', 'a', 'l', 'c', 'P', 'a', 'r', 'a', 0,
    'r', 'a', 'c', 'c', 'o', 'r', 'd', 'o', 0,
    'c', 'l', 'i', 'p', 'P', 'o', 'l', 'y', 0,
    't', 'o', 's', 't', 'r', 'i', 'n', 'g', 0,
    'r', 'e', 'v', 'e', 'r', 's', 'e', 'd', 0,
    'c', 'S', 'c', 'a', 'l', 'e', 'X', 'Y', 0,
    's', 'i', 'n', 'g', 'u', 'l', 'a', 'r', 0,
    'i', 's', 'M', 'i', 'r', 'r', 'o', 'r', 0,
    '_', '_', 'r', 'e', 'p', 'r', '_', '_', 0,
    '_', '_', 'h', 'a', 's', 'h', '_', '_', 0,
    '_', '_', 'c', 'a', 'l', 'l', '_', '_', 0,
    'g', 'e', 't', 'R', 'e', 'c', 't', 0,
    'g', 'e', 't', 'A', 'r', 'e', 'a', 0,
    'P', 'a', 'c', 'k', 'i', 'n', 'g', 0,
    'a', 'd', 'd', 'P', 'a', 'r', 't', 0,
    'i', 's', 'p', 'l', 'i', 'n', 'e', 0,
    'h', 'e', 'r', 'm', 'i', 't', 'e', 0,
    's', 'p', 'l', 'i', 'n', 'e', 'X', 0,
    'o', 'f', 'f', 's', 'e', 't', 'f', 0,
    'o', 'd', 'd', 'E', 'v', 'e', 'n', 0,
    'r', 'e', 'v', 'e', 'r', 's', 'e', 0,
    's', 'e', 'g', 'm', 'e', 'n', 't', 0,
    's', 'c', 'a', 'l', 'e', 'x', 'y', 0,
    'x', 'p', 'o', 's', 'i', 'n', 'v', 0,
    'p', 'r', 'o', 'j', 'e', 'c', 't', 0,
    '_', '_', 'x', 'o', 'r', '_', '_', 0,
    '_', '_', 'd', 'i', 'v', '_', '_', 0,
    '_', '_', 'm', 'u', 'l', '_', '_', 0,
    '_', '_', 'n', 'e', 'g', '_', '_', 0,
    '_', '_', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'c', 'm', 'p', '_', '_', 0,
    '_', '_', 'a', 'b', 's', '_', '_', 0,
    '_', '_', 'l', 'e', 'n', '_', '_', 0,
    'i', 's', 'V', 'a', 'l', 'i', 'd', 0,
    'c', 'e', 'n', 't', 'e', 'r', 0,
    'N', 'D', 'V', 'e', 'c', 't', 0,
    'b', 'l', 'o', 'c', 'k', 's', 0,
    'r', 'o', 't', 'a', 't', 'e', 0,
    'm', 'a', 'x', '_', 's', 'e', 0,
    'x', 's', 'a', 'r', 'e', 'a', 0,
    'D', 'e', 'f', 'e', 'c', 't', 0,
    'i', 'n', 's', 'i', 'd', 'e', 0,
    'h', 'e', 'i', 'g', 'h', 't', 0,
    'u', 'n', 'i', 's', 'c', 'i', 0,
    'o', 'r', 'i', 'e', 'n', 't', 0,
    'r', 'e', 'f', 'i', 'n', 'e', 0,
    'p', 'o', 'i', 'n', 't', 's', 0,
    'P', 'a', 't', 'h', '2', 'd', 0,
    'm', 'i', 'r', 'r', 'o', 'r', 0,
    'c', 'S', 'c', 'a', 'l', 'e', 0,
    '_', '_', 'n', 'e', '_', '_', 0,
    '_', '_', 'e', 'q', '_', '_', 0,
    'c', 'l', 'e', 'a', 'r', 0,
    'x', 's', 'e', 'c', 't', 0,
    's', 'c', 'o', 'r', 'e', 0,
    'm', 'e', 'r', 'g', 'e', 0,
    'a', 'r', 'e', 'a', 's', 0,
    'w', 'i', 'd', 't', 'h', 0,
    's', 'h', 'a', 'p', 'e', 0,
    'p', 'a', 'r', 'a', 'f', 0,
    'p', 'a', 't', 'h', 's', 0,
    'b', 'e', 'z', 't', 'o', 0,
    'x', 'f', 'o', 'r', 'm', 0,
    's', 'c', 'a', 'l', 'e', 0,
    'x', 'l', 'a', 't', 'e', 0,
    'a', 'n', 'g', 'l', 'e', 0,
    'o', 'r', 't', 'h', 'o', 0,
    'I', 'S', 'u', 'r', 'f', 0,
    'c', 'a', 'l', 'c', 0,
    'g', 'r', 'i', 'd', 0,
    'p', 'a', 'c', 'k', 0,
    'b', 'u', 'm', 'p', 0,
    's', 'i', 'z', 'e', 0,
    'd', 'a', 's', 'h', 0,
    't', 'a', 'n', 'r', 0,
    't', 'a', 'n', 'l', 0,
    'c', 'R', 'o', 't', 0,
    't', 'o', 'G', 'L', 0,
    'm', 's', 'g', 0,
    'n', 'u', 'm', 0,
    'v', 't', 's', 0,
    's', 's', 'e', 0,
    'i', 'd', '2', 0,
    'i', 'd', '1', 0,
    'n', 'e', 't', 0,
    'p', 'o', 's', 0,
    't', 'a', 'n', 0,
    'l', 'e', 'n', 0,
    'r', 'o', 't', 0,
    'X', '2', 'd', 0,
    'c', 'a', 'p', 0,
    'a', 'r', 'g', 0,
    'd', 'i', 'r', 0,
    'P', '2', 'd', 0,
    'p', 't', 's', 0,
    'S', '1', 0,
    'x', '2', 0,
    'x', '1', 0,
    'n', 'd', 0,
    'S', 0,
    'D', 0,
    'w', 0,
    'q', 0,
    'A', 0,
    'b', 0,
};
#line 2 "sip/geo2dx.sip"
  static inline X2d rot(double alpha) { return X2d::rot(alpha); }
  static inline X2d xlate(const P2d& t) { return X2d::xlate(t); }
  static inline X2d scale(double s) { return X2d::scale(s); }
  static inline X2d scale(double x,double y) { return X2d::scale(x,y); }
  static inline X2d rot(const P2d& c,double alpha) { return X2d::rot(c,alpha); }
  static X2d scale(const P2d& c,double s) { return X2d::scale(c,s); }
  static X2d scale(const P2d& c,double x,double y)  { return X2d::scale(c,x,y); }
  static X2d xform(const P2d& a1,const P2d& b1,
                   const P2d& a2,const P2d& b2) { return X2d::xform(a1,b1,a2,b2); }
  static X2d mirror(const P2d& a,const P2d& b) { return X2d::mirror(a,b); }
#line 10 "sip/geo2dpath.sip"
static PyObject*
ProjectResult_getpoint(PyObject *self, void *closure)
{
    PyObject *o = PyTuple_GetItem(self, 0);
    Py_INCREF(o);
    return o;
}

static PyObject*
ProjectResult_getdist(PyObject *self, void *closure)
{
    PyObject *o = PyTuple_GetItem(self, 1);
    Py_INCREF(o);
    return o;
}

static PyObject*
ProjectResult_getlength(PyObject *self, void *closure)
{
    PyObject *o = PyTuple_GetItem(self, 2);
    Py_INCREF(o);
    return o;
}

static PyObject*
ProjectResult_getsegment(PyObject *self, void *closure)
{
    PyObject *o = PyTuple_GetItem(self, 3);
    Py_INCREF(o);
    return o;
}

static PyObject *
ProjectResult_repr(PyObject *self)
{
    PyObject *r = PyString_FromString(self->ob_type->tp_name);

    PyString_ConcatAndDel(&r, PyString_FromString("("));
    PyString_ConcatAndDel(&r, PyTuple_Type.tp_repr(self));
    PyString_ConcatAndDel(&r, PyString_FromString(")"));

    return r;
}

static char ProjectResult_doc[] =
    "Tupla che tiene il valore di ritorno di Path.project, e permette di\n"
    "accedere ai vari elementi per nome.";

static PyGetSetDef ProjectResult_getseters[] = {
    { (char*)"p",        (getter)ProjectResult_getpoint },
    { (char*)"pt",       (getter)ProjectResult_getpoint },
    { (char*)"point",    (getter)ProjectResult_getpoint },

    { (char*)"d",        (getter)ProjectResult_getdist },
    { (char*)"dist",     (getter)ProjectResult_getdist },
    { (char*)"distance", (getter)ProjectResult_getdist },

    { (char*)"t",        (getter)ProjectResult_getlength },
    { (char*)"len",      (getter)ProjectResult_getlength },
    { (char*)"length",   (getter)ProjectResult_getlength },

    { (char*)"s",        (getter)ProjectResult_getsegment },
    { (char*)"seg",      (getter)ProjectResult_getsegment },
    { (char*)"segment",  (getter)ProjectResult_getsegment },

    { NULL },
};

PyTypeObject ProjectResult_Type = {
	PyObject_HEAD_INIT(&PyType_Type)
	0,					/* ob_size */
	"geo2d.ProjectResult",			/* tp_name */
	sizeof(ProjectResult_Type),		/* tp_basicsize */
	0,					/* tp_itemsize */
	/* methods */
	0,                       		/* tp_dealloc */
	0,					/* tp_print */
	0, 					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)ProjectResult_repr,		/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,	                                /* tp_str */
	0,		                        /* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,                     /* tp_flags */
 	ProjectResult_doc,		        /* tp_doc */
 	0,		                        /* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,	                                /* tp_weaklistoffset */
	0,			                /* tp_iter */
	0,		                        /* tp_iternext */
	0,					/* tp_methods */
	0,				        /* tp_members */
	ProjectResult_getseters,                /* tp_getset */
	&PyTuple_Type,			        /* tp_base */
	0,					/* tp_dict */
};

#line 358 "sip_geo2dcppcmodule.cpp"


extern "C" {static PyObject *func_NDVect(PyObject *,PyObject *);}
static PyObject *func_NDVect(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "dd", &a0, &a1))
        {
            NDVector *sipRes;

            sipRes = new NDVector(NDVect(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_NDVector,NULL);
        }
    }

    {
        double a0;
        double a1;
        double a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "ddd", &a0, &a1, &a2))
        {
            NDVector *sipRes;

            sipRes = new NDVector(NDVect(a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_NDVector,NULL);
        }
    }

    {
        double a0;
        double a1;
        double a2;
        double a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "dddd", &a0, &a1, &a2, &a3))
        {
            NDVector *sipRes;

            sipRes = new NDVector(NDVect(a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_NDVector,NULL);
        }
    }

    {
        double a0;
        double a1;
        double a2;
        double a3;
        double a4;

        if (sipParseArgs(&sipParseErr, sipArgs, "ddddd", &a0, &a1, &a2, &a3, &a4))
        {
            NDVector *sipRes;

            sipRes = new NDVector(NDVect(a0,a1,a2,a3,a4));

            return sipConvertFromNewType(sipRes,sipType_NDVector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_NDVect, NULL);

    return NULL;
}


extern "C" {static PyObject *func_blocks(PyObject *,PyObject *);}
static PyObject *func_blocks(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        double a1;
        bool a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1d|b", sipType_std_vector_0100Path2d,&a0, &a0State, &a1, &a2))
        {
            BlocksInfo *sipRes;

            sipRes = new BlocksInfo(blocks(*a0,a1,a2));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_BlocksInfo,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_blocks, NULL);

    return NULL;
}


extern "C" {static PyObject *func_vecpath_test(PyObject *,PyObject *);}
static PyObject *func_vecpath_test(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "ii", &a0, &a1))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(vecpath_test(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_vecpath_test, NULL);

    return NULL;
}


extern "C" {static PyObject *func_vecvecpath_test(PyObject *,PyObject *);}
static PyObject *func_vecvecpath_test(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "ii", &a0, &a1))
        {
            std::vector<std::vector<Path2d> > *sipRes;

            sipRes = new std::vector<std::vector<Path2d> >(vecvecpath_test(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0600std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_vecvecpath_test, NULL);

    return NULL;
}


extern "C" {static PyObject *func_mapvecpath_test(PyObject *,PyObject *);}
static PyObject *func_mapvecpath_test(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        int a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "ii", &a0, &a1))
        {
            std::map<int,std::vector<Path2d> > *sipRes;

            sipRes = new std::map<int,std::vector<Path2d> >(mapvecpath_test(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_std_map_1800_0600std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_mapvecpath_test, NULL);

    return NULL;
}


extern "C" {static PyObject *func_get_weights(PyObject *,PyObject *);}
static PyObject *func_get_weights(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const std::vector<double> * a1;
        int a1State = 0;
        const std::vector<P2d> * a2;
        int a2State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1J1", sipType_Path2d, &a0, sipType_std_vector_2400,&a1, &a1State, sipType_std_vector_0100P2d,&a2, &a2State))
        {
            std::vector<double> *sipRes;

            sipRes = new std::vector<double>(get_weights(*a0,*a1,*a2));
            sipReleaseType(const_cast<std::vector<double> *>(a1),sipType_std_vector_2400,a1State);
            sipReleaseType(const_cast<std::vector<P2d> *>(a2),sipType_std_vector_0100P2d,a2State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_2400,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_get_weights, NULL);

    return NULL;
}


extern "C" {static PyObject *func_uniform_sampling(PyObject *,PyObject *);}
static PyObject *func_uniform_sampling(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        int a1;
        double a2;
        double a3 = 0;
        double a4 = -1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9i|dd", sipType_Path2d, &a0, &a1, &a3, &a4))
        {
            PyObject * sipRes = 0;

#line 37 "sip/path_matching.sip"
    double r1 = 0.0;
    std::vector<P2d>* r0 = new std::vector<P2d>( uniform_sampling(*a0, a1, &r1) );
    // a2 is a double, that SIP probably tries to "backport" to the passed argument
    // even if it isn't like that, it's better than leaving it uninitialized as it was
    // previously (see the generated code)
    a2 = r1;
    const sipMappedType *mt = sipFindMappedType("std::vector<P2d>");
    PyObject *pobj = sipConvertFromMappedType(r0, mt, NULL);
    
    sipRes = PyTuple_New(2);
    PyTuple_SetItem(sipRes, 0, pobj);
    PyTuple_SetItem(sipRes, 1, PyFloat_FromDouble(r1));
#line 602 "sip_geo2dcppcmodule.cpp"

            return sipBuildResult(0,"(Rd)",sipRes,a2);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_uniform_sampling, NULL);

    return NULL;
}


extern "C" {static PyObject *func_fixed_sampling(PyObject *,PyObject *);}
static PyObject *func_fixed_sampling(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        double a1;
        double a2 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9d|d", sipType_Path2d, &a0, &a1, &a2))
        {
            std::vector<P2d> *sipRes;

            sipRes = new std::vector<P2d>(fixed_sampling(*a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_fixed_sampling, NULL);

    return NULL;
}


extern "C" {static PyObject *func_vecpathOverVecpath(PyObject *,PyObject *);}
static PyObject *func_vecpathOverVecpath(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const std::vector<Path2d> * a1;
        int a1State = 0;
        double a2 = 15;
        double a3 = 100;
        double a4 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1|ddd", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_std_vector_0100Path2d,&a1, &a1State, &a2, &a3, &a4))
        {
            std::vector<match_result> *sipRes;

            sipRes = new std::vector<match_result>(vecpathOverVecpath(*a0,*a1,a2,a3,a4));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a1),sipType_std_vector_0100Path2d,a1State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100match_result,NULL);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const std::vector<std::vector<double> > * a1;
        int a1State = 0;
        const std::vector<Path2d> * a2;
        int a2State = 0;
        const std::vector<std::vector<double> > * a3;
        int a3State = 0;
        double a4 = 15;
        double a5 = 100;
        double a6 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1J1J1|ddd", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_std_vector_0600std_vector_2400,&a1, &a1State, sipType_std_vector_0100Path2d,&a2, &a2State, sipType_std_vector_0600std_vector_2400,&a3, &a3State, &a4, &a5, &a6))
        {
            std::vector<match_result> *sipRes;

            sipRes = new std::vector<match_result>(vecpathOverVecpath(*a0,*a1,*a2,*a3,a4,a5,a6));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<std::vector<double> > *>(a1),sipType_std_vector_0600std_vector_2400,a1State);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a2),sipType_std_vector_0100Path2d,a2State);
            sipReleaseType(const_cast<std::vector<std::vector<double> > *>(a3),sipType_std_vector_0600std_vector_2400,a3State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100match_result,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_vecpathOverVecpath, NULL);

    return NULL;
}


extern "C" {static PyObject *func_vecpathOverPath(PyObject *,PyObject *);}
static PyObject *func_vecpathOverPath(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const Path2d * a1;
        double a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J9d", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_Path2d, &a1, &a2))
        {
            match_result *sipRes;

            sipRes = new match_result(vecpathOverPath(*a0,*a1,a2));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_match_result,NULL);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const std::vector<std::vector<double> > * a1;
        int a1State = 0;
        const Path2d * a2;
        const std::vector<double> * a3;
        int a3State = 0;
        double a4 = 100;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1J9J1|d", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_std_vector_0600std_vector_2400,&a1, &a1State, sipType_Path2d, &a2, sipType_std_vector_2400,&a3, &a3State, &a4))
        {
            match_result *sipRes;

            sipRes = new match_result(vecpathOverPath(*a0,*a1,*a2,*a3,a4));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<std::vector<double> > *>(a1),sipType_std_vector_0600std_vector_2400,a1State);
            sipReleaseType(const_cast<std::vector<double> *>(a3),sipType_std_vector_2400,a3State);

            return sipConvertFromNewType(sipRes,sipType_match_result,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_vecpathOverPath, NULL);

    return NULL;
}


extern "C" {static PyObject *func_pathOverPath(PyObject *,PyObject *);}
static PyObject *func_pathOverPath(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const Path2d * a1;
        double a2 = 100;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Path2d, &a0, sipType_Path2d, &a1, &a2))
        {
            match_result *sipRes;

            sipRes = new match_result(pathOverPath(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_match_result,NULL);
        }
    }

    {
        const Path2d * a0;
        std::vector<double> * a1;
        int a1State = 0;
        const Path2d * a2;
        std::vector<double> * a3;
        int a3State = 0;
        double a4 = 100;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1J9J1|d", sipType_Path2d, &a0, sipType_std_vector_2400,&a1, &a1State, sipType_Path2d, &a2, sipType_std_vector_2400,&a3, &a3State, &a4))
        {
            match_result *sipRes;

            sipRes = new match_result(pathOverPath(*a0,*a1,*a2,*a3,a4));
            sipReleaseType(a1,sipType_std_vector_2400,a1State);
            sipReleaseType(a3,sipType_std_vector_2400,a3State);

            return sipConvertFromNewType(sipRes,sipType_match_result,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_pathOverPath, NULL);

    return NULL;
}


extern "C" {static PyObject *func_points_matching(PyObject *,PyObject *);}
static PyObject *func_points_matching(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        const std::vector<P2d> * a1;
        int a1State = 0;
        bool a2 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1|b", sipType_std_vector_0100P2d,&a0, &a0State, sipType_std_vector_0100P2d,&a1, &a1State, &a2))
        {
            match_result *sipRes;

            sipRes = new match_result(points_matching(*a0,*a1,a2));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);
            sipReleaseType(const_cast<std::vector<P2d> *>(a1),sipType_std_vector_0100P2d,a1State);

            return sipConvertFromNewType(sipRes,sipType_match_result,NULL);
        }
    }

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        const std::vector<P2d> * a1;
        int a1State = 0;
        const std::vector<double> * a2;
        int a2State = 0;
        bool a3 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1J1|b", sipType_std_vector_0100P2d,&a0, &a0State, sipType_std_vector_0100P2d,&a1, &a1State, sipType_std_vector_2400,&a2, &a2State, &a3))
        {
            match_result *sipRes;

            sipRes = new match_result(points_matching(*a0,*a1,*a2,a3));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);
            sipReleaseType(const_cast<std::vector<P2d> *>(a1),sipType_std_vector_0100P2d,a1State);
            sipReleaseType(const_cast<std::vector<double> *>(a2),sipType_std_vector_2400,a2State);

            return sipConvertFromNewType(sipRes,sipType_match_result,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_points_matching, NULL);

    return NULL;
}


extern "C" {static PyObject *func_rects_cover(PyObject *,PyObject *);}
static PyObject *func_rects_cover(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        int a1;
        int a2 = 10;
        bool a3 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1i|ib", sipType_std_vector_0100Path2d,&a0, &a0State, &a1, &a2, &a3))
        {
            std::vector<coveringRect> *sipRes;

            sipRes = new std::vector<coveringRect>(rects_cover(*a0,a1,a2,a3));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100coveringRect,NULL);
        }
    }

    {
        const Path2d * a0;
        int a1;
        int a2 = 10;
        bool a3 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9i|ib", sipType_Path2d, &a0, &a1, &a2, &a3))
        {
            std::vector<coveringRect> *sipRes;

            sipRes = new std::vector<coveringRect>(rects_cover(*a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100coveringRect,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_rects_cover, NULL);

    return NULL;
}


extern "C" {static PyObject *func_pack(PyObject *,PyObject *);}
static PyObject *func_pack(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        X2d * a1;
        const std::vector<Path2d> * a2;
        int a2State = 0;
        X2d * a3;
        int a4;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J9J1J9i", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_X2d, &a1, sipType_std_vector_0100Path2d,&a2, &a2State, sipType_X2d, &a3, &a4))
        {
            double sipRes;

            sipRes = pack(*a0,*a1,*a2,*a3,a4);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a2),sipType_std_vector_0100Path2d,a2State);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        X2d * a1;
        std::vector<std::vector<Path2d> > * a2;
        int a2State = 0;
        X2d * a3;
        int a4;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J9J1J9i", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_X2d, &a1, sipType_std_vector_0600std_vector_0100Path2d,&a2, &a2State, sipType_X2d, &a3, &a4))
        {
            int sipRes;

            sipRes = pack(*a0,*a1,*a2,*a3,a4);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(a2,sipType_std_vector_0600std_vector_0100Path2d,a2State);

            return SIPLong_FromLong(sipRes);
        }
    }

    {
        std::vector<std::vector<Path2d> > * a0;
        int a0State = 0;
        int a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1i", sipType_std_vector_0600std_vector_0100Path2d,&a0, &a0State, &a1))
        {
            std::vector<Packing> *sipRes;

            sipRes = new std::vector<Packing>(pack(*a0,a1));
            sipReleaseType(a0,sipType_std_vector_0600std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Packing,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_pack, NULL);

    return NULL;
}


extern "C" {static PyObject *func_unione_path(PyObject *,PyObject *);}
static PyObject *func_unione_path(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::vector<Path2d> * a0;
        int a0State = 0;
        double a1 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|d", sipType_std_vector_0100Path2d,&a0, &a0State, &a1))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(unione_path(*a0,a1));
            sipReleaseType(a0,sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_unione_path, NULL);

    return NULL;
}


extern "C" {static PyObject *func_complexSplineXC(PyObject *,PyObject *);}
static PyObject *func_complexSplineXC(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        std::vector<int> * a1;
        int a1State = 0;
        int a2 = 6;
        bool a3 = 0;
        int a4 = 20;
        double a5 = 1.62;
        int a6 = 0;
        std::vector<int> * a7;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1|ibidi", sipType_std_vector_0100P2d,&a0, &a0State, sipType_std_vector_1800,&a1, &a1State, &a2, &a3, &a4, &a5, &a6))
        {
            std::vector<P2d> *sipRes;
            a7 = new std::vector<int>();

            sipRes = new std::vector<P2d>(complexSplineXC(*a0,*a1,a2,a3,a4,a5,a6,a7));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);
            sipReleaseType(a1,sipType_std_vector_1800,a1State);

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_std_vector_0100P2d,NULL);
            return sipBuildResult(0,"(RN)",sipResObj,a7,sipType_std_vector_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_complexSplineXC, NULL);

    return NULL;
}


extern "C" {static PyObject *func_oldSplineX(PyObject *,PyObject *);}
static PyObject *func_oldSplineX(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        std::vector<int> * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100P2d,&a0, &a0State))
        {
            Path2d *sipRes;
            a1 = new std::vector<int>();

            sipRes = new Path2d(oldSplineX(*a0,a1));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
            return sipBuildResult(0,"(RN)",sipResObj,a1,sipType_std_vector_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_oldSplineX, NULL);

    return NULL;
}


extern "C" {static PyObject *func_xsarea(PyObject *,PyObject *);}
static PyObject *func_xsarea(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const X2d * a1;
        const Path2d * a2;
        const X2d * a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9J9", sipType_Path2d, &a0, sipType_X2d, &a1, sipType_Path2d, &a2, sipType_X2d, &a3))
        {
            double sipRes;

            sipRes = xsarea(*a0,*a1,*a2,*a3);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const X2d * a1;
        const std::vector<Path2d> * a2;
        int a2State = 0;
        const X2d * a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J9J1J9", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_X2d, &a1, sipType_std_vector_0100Path2d,&a2, &a2State, sipType_X2d, &a3))
        {
            double sipRes;

            sipRes = xsarea(*a0,*a1,*a2,*a3);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a2),sipType_std_vector_0100Path2d,a2State);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_xsarea, NULL);

    return NULL;
}


extern "C" {static PyObject *func_areas(PyObject *,PyObject *);}
static PyObject *func_areas(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const std::vector<Path2d> * a1;
        int a1State = 0;
        const std::vector<QualityMarker> * a2;
        int a2State = 0;
        const std::vector<Defect> * a3;
        int a3State = 0;
        int a4;
        int a5;
        double a6;
        bool a7 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1J1J1iid|b", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_std_vector_0100Path2d,&a1, &a1State, sipType_std_vector_0100QualityMarker,&a2, &a2State, sipType_std_vector_0100Defect,&a3, &a3State, &a4, &a5, &a6, &a7))
        {
            std::vector<std::vector<Path2d> > *sipRes;

            sipRes = new std::vector<std::vector<Path2d> >(areas(*a0,*a1,*a2,*a3,a4,a5,a6,a7));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a1),sipType_std_vector_0100Path2d,a1State);
            sipReleaseType(const_cast<std::vector<QualityMarker> *>(a2),sipType_std_vector_0100QualityMarker,a2State);
            sipReleaseType(const_cast<std::vector<Defect> *>(a3),sipType_std_vector_0100Defect,a3State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0600std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_areas, NULL);

    return NULL;
}


extern "C" {static PyObject *func_unionAreaValue(PyObject *,PyObject *);}
static PyObject *func_unionAreaValue(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<std::vector<Path2d> > * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0600std_vector_0100Path2d,&a0, &a0State))
        {
            double sipRes;

            sipRes = unionAreaValue(*a0);
            sipReleaseType(const_cast<std::vector<std::vector<Path2d> > *>(a0),sipType_std_vector_0600std_vector_0100Path2d,a0State);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_unionAreaValue, NULL);

    return NULL;
}


extern "C" {static PyObject *func_unionAreaPaths(PyObject *,PyObject *);}
static PyObject *func_unionAreaPaths(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<std::vector<Path2d> > * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0600std_vector_0100Path2d,&a0, &a0State))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(unionAreaPaths(*a0));
            sipReleaseType(const_cast<std::vector<std::vector<Path2d> > *>(a0),sipType_std_vector_0600std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_unionAreaPaths, NULL);

    return NULL;
}


extern "C" {static PyObject *func_sarea(PyObject *,PyObject *);}
static PyObject *func_sarea(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            double sipRes;

            sipRes = sarea(*a0);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_sarea, NULL);

    return NULL;
}


extern "C" {static PyObject *func_area(PyObject *,PyObject *);}
static PyObject *func_area(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            double sipRes;

            sipRes = area(*a0);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        int a1 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|i", sipType_std_vector_0100Path2d,&a0, &a0State, &a1))
        {
            double sipRes;

            sipRes = area(*a0,a1);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_area, NULL);

    return NULL;
}


extern "C" {static PyObject *func_self_intersections(PyObject *,PyObject *);}
static PyObject *func_self_intersections(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            std::vector<P2d> *sipRes;

            sipRes = new std::vector<P2d>(self_intersections(*a0));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_self_intersections, NULL);

    return NULL;
}


extern "C" {static PyObject *func_intersections(PyObject *,PyObject *);}
static PyObject *func_intersections(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const Path2d * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_Path2d, &a0, sipType_Path2d, &a1))
        {
            std::vector<P2d> *sipRes;

            sipRes = new std::vector<P2d>(intersections(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_intersections, NULL);

    return NULL;
}


extern "C" {static PyObject *func_intersect(PyObject *,PyObject *);}
static PyObject *func_intersect(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const Path2d * a1;
        bool a2 = 1;
        double a3 = 1e-05;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|bd", sipType_Path2d, &a0, sipType_Path2d, &a1, &a2, &a3))
        {
            bool sipRes;

            sipRes = intersect(*a0,*a1,a2,a3);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Path2d * a0;
        const std::vector<Path2d> * a1;
        int a1State = 0;
        bool a2 = 1;
        double a3 = 1e-05;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1|bd", sipType_Path2d, &a0, sipType_std_vector_0100Path2d,&a1, &a1State, &a2, &a3))
        {
            bool sipRes;

            sipRes = intersect(*a0,*a1,a2,a3);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a1),sipType_std_vector_0100Path2d,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        const std::vector<Path2d> * a1;
        int a1State = 0;
        bool a2 = 1;
        double a3 = 1e-05;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1|bd", sipType_std_vector_0100Path2d,&a0, &a0State, sipType_std_vector_0100Path2d,&a1, &a1State, &a2, &a3))
        {
            bool sipRes;

            sipRes = intersect(*a0,*a1,a2,a3);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a1),sipType_std_vector_0100Path2d,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const P2d * a0;
        const P2d * a1;
        const P2d * a2;
        const P2d * a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9J9", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2, sipType_P2d, &a3))
        {
            bool sipRes;

            sipRes = intersect(*a0,*a1,*a2,*a3);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            bool sipRes;

            sipRes = intersect(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_intersect, NULL);

    return NULL;
}


extern "C" {static PyObject *func_inside_equal(PyObject *,PyObject *);}
static PyObject *func_inside_equal(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const Path2d * a1;
        bool a2 = 1;
        double a3 = 1e-07;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|bd", sipType_P2d, &a0, sipType_Path2d, &a1, &a2, &a3))
        {
            bool sipRes;

            sipRes = inside_equal(*a0,*a1,a2,a3);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_inside_equal, NULL);

    return NULL;
}


extern "C" {static PyObject *func_inside(PyObject *,PyObject *);}
static PyObject *func_inside(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const Path2d * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_P2d, &a0, sipType_Path2d, &a1))
        {
            bool sipRes;

            sipRes = inside(*a0,*a1);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const P2d * a0;
        const std::vector<Path2d> * a1;
        int a1State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1", sipType_P2d, &a0, sipType_std_vector_0100Path2d,&a1, &a1State))
        {
            bool sipRes;

            sipRes = inside(*a0,*a1);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a1),sipType_std_vector_0100Path2d,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_inside, NULL);

    return NULL;
}


extern "C" {static PyObject *func_calcPara(PyObject *,PyObject *);}
static PyObject *func_calcPara(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        double a1;
        std::vector<Path2d> * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1d", sipType_std_vector_0100Path2d,&a0, &a0State, &a1))
        {
            a2 = new std::vector<Path2d>();

            calcPara(*a0,a1,*a2);
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(a2,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_calcPara, NULL);

    return NULL;
}


extern "C" {static PyObject *func_ispline(PyObject *,PyObject *);}
static PyObject *func_ispline(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        double a1 = 0.05;
        unsigned a2 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9|du", sipType_Path2d, &a0, &a1, &a2))
        {
            std::vector<P2d> *sipRes;

            sipRes = new std::vector<P2d>(ispline(*a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_ispline, NULL);

    return NULL;
}


extern "C" {static PyObject *func_hermite(PyObject *,PyObject *);}
static PyObject *func_hermite(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;
        const P2d * a2;
        const P2d * a3;
        int a4;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9J9i", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2, sipType_P2d, &a3, &a4))
        {
            Path2d *sipRes;

            sipRes = new Path2d(hermite(*a0,*a1,*a2,*a3,a4));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_hermite, NULL);

    return NULL;
}


extern "C" {static PyObject *func_splineX(PyObject *,PyObject *);}
static PyObject *func_splineX(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        std::vector<int> * a1;
        int a2 = 6;
        bool a3 = 0;
        int a4 = 20;
        double a5 = 1.62;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|ibid", sipType_std_vector_0100P2d,&a0, &a0State, &a2, &a3, &a4, &a5))
        {
            Path2d *sipRes;
            a1 = new std::vector<int>();

            sipRes = new Path2d(splineX(*a0,a1,a2,a3,a4,a5));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
            return sipBuildResult(0,"(RN)",sipResObj,a1,sipType_std_vector_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_splineX, NULL);

    return NULL;
}


extern "C" {static PyObject *func_triangulate(PyObject *,PyObject *);}
static PyObject *func_triangulate(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        std::vector<int> * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            a1 = new std::vector<int>();

            triangulate(*a0,*a1);

            return sipConvertFromNewType(a1,sipType_std_vector_1800,NULL);
        }
    }

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        std::vector<int> * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100P2d,&a0, &a0State))
        {
            a1 = new std::vector<int>();

            triangulate(*a0,*a1);
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);

            return sipConvertFromNewType(a1,sipType_std_vector_1800,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_triangulate, NULL);

    return NULL;
}


extern "C" {static PyObject *func_unisci(PyObject *,PyObject *);}
static PyObject *func_unisci(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        Path2d * a0;
        double a1;
        double a2;
        Path2d * a3;
        double a4;
        double a5;
        double a6;
        double a7;
        double a8;
        double a9;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9ddJ9dddd", sipType_Path2d, &a0, &a1, &a2, sipType_Path2d, &a3, &a4, &a5, &a6, &a7))
        {
            P2d *sipRes;

            sipRes = new P2d(unisci(*a0,a1,a2,*a3,a4,a5,a6,a7,&a8,&a9));

            PyObject *sipResObj = sipConvertFromNewType(sipRes,sipType_P2d,NULL);
            return sipBuildResult(0,"(Rdd)",sipResObj,a8,a9);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_unisci, NULL);

    return NULL;
}


extern "C" {static PyObject *func_quasi_convex_hull(PyObject *,PyObject *);}
static PyObject *func_quasi_convex_hull(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1d", sipType_std_vector_0100Path2d,&a0, &a0State, &a1))
        {
            Path2d *sipRes;

            sipRes = new Path2d(quasi_convex_hull(*a0,a1));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_quasi_convex_hull, NULL);

    return NULL;
}


extern "C" {static PyObject *func_regularize(PyObject *,PyObject *);}
static PyObject *func_regularize(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            Path2d *sipRes;

            sipRes = new Path2d(regularize(*a0));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_regularize, NULL);

    return NULL;
}


extern "C" {static PyObject *func_convex_hull_presorted(PyObject *,PyObject *);}
static PyObject *func_convex_hull_presorted(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<P2d> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100P2d,&a0, &a0State))
        {
            Path2d *sipRes;

            sipRes = new Path2d(convex_hull_presorted(*a0));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_convex_hull_presorted, NULL);

    return NULL;
}


extern "C" {static PyObject *func_convex_hull(PyObject *,PyObject *);}
static PyObject *func_convex_hull(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            Path2d *sipRes;

            sipRes = new Path2d(convex_hull(*a0));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100Path2d,&a0, &a0State))
        {
            Path2d *sipRes;

            sipRes = new Path2d(convex_hull(*a0));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    {
        std::vector<P2d> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100P2d,&a0, &a0State))
        {
            Path2d *sipRes;

            sipRes = new Path2d(convex_hull(*a0));
            sipReleaseType(a0,sipType_std_vector_0100P2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_convex_hull, NULL);

    return NULL;
}


extern "C" {static PyObject *func_simplify_contained(PyObject *,PyObject *);}
static PyObject *func_simplify_contained(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        Path2d * a0;
        int a1 = 0;
        int a2 = 1;
        double a3 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9|iid", sipType_Path2d, &a0, &a1, &a2, &a3))
        {
            Path2d *sipRes;

            sipRes = new Path2d(simplify_contained(*a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_simplify_contained, NULL);

    return NULL;
}


extern "C" {static PyObject *func_simplifyf(PyObject *,PyObject *);}
static PyObject *func_simplifyf(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        Path2d * a0;
        double a1 = 0.01;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9|d", sipType_Path2d, &a0, &a1))
        {
            Path2d *sipRes;

            sipRes = new Path2d(_simplify(*a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    {
        std::vector<P2d> * a0;
        int a0State = 0;
        double a1 = 0.01;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1|d", sipType_std_vector_0100P2d,&a0, &a0State, &a1))
        {
            std::vector<P2d> *sipRes;

            sipRes = new std::vector<P2d>(_simplify(*a0,a1));
            sipReleaseType(a0,sipType_std_vector_0100P2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_simplifyf, NULL);

    return NULL;
}


extern "C" {static PyObject *func_enlarge_area(PyObject *,PyObject *);}
static PyObject *func_enlarge_area(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::vector<Path2d> * a0;
        int a0State = 0;
        double a1;
        double a2 = 0.01;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1d|d", sipType_std_vector_0100Path2d,&a0, &a0State, &a1, &a2))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(enlarge_area(*a0,a1,a2));
            sipReleaseType(a0,sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_enlarge_area, NULL);

    return NULL;
}


extern "C" {static PyObject *func_nd(PyObject *,PyObject *);}
static PyObject *func_nd(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        int a1;
        double a2;
        bool a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9idb", sipType_Path2d, &a0, &a1, &a2, &a3))
        {
            P2d *sipRes;

            sipRes = new P2d(nd(*a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_nd, NULL);

    return NULL;
}


extern "C" {static PyObject *func_offsetf(PyObject *,PyObject *);}
static PyObject *func_offsetf(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        Path2d * a0;
        const std::vector<double> * a1;
        int a1State = 0;
        int a2;
        double a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J1id", sipType_Path2d, &a0, sipType_std_vector_2400,&a1, &a1State, &a2, &a3))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(offset(*a0,*a1,a2,a3));
            sipReleaseType(const_cast<std::vector<double> *>(a1),sipType_std_vector_2400,a1State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    {
        std::vector<P2d> * a0;
        int a0State = 0;
        const std::vector<double> * a1;
        int a1State = 0;
        int a2;
        double a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1J1id", sipType_std_vector_0100P2d,&a0, &a0State, sipType_std_vector_2400,&a1, &a1State, &a2, &a3))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(offset(*a0,*a1,a2,a3));
            sipReleaseType(a0,sipType_std_vector_0100P2d,a0State);
            sipReleaseType(const_cast<std::vector<double> *>(a1),sipType_std_vector_2400,a1State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_offsetf, NULL);

    return NULL;
}


extern "C" {static PyObject *func_paraf(PyObject *,PyObject *);}
static PyObject *func_paraf(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        double a1;
        bool a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9db", sipType_Path2d, &a0, &a1, &a2))
        {
            Path2d *sipRes;

            sipRes = new Path2d(para(*a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        double a1;
        bool a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1db", sipType_std_vector_0100P2d,&a0, &a0State, &a1, &a2))
        {
            Path2d *sipRes;

            sipRes = new Path2d(para(*a0,a1,a2));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_paraf, NULL);

    return NULL;
}


extern "C" {static PyObject *func_para_smussaf(PyObject *,PyObject *);}
static PyObject *func_para_smussaf(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        double a1;
        bool a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9db", sipType_Path2d, &a0, &a1, &a2))
        {
            Path2d *sipRes;

            sipRes = new Path2d(para_smussa(*a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    {
        const std::vector<P2d> * a0;
        int a0State = 0;
        double a1;
        bool a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1db", sipType_std_vector_0100P2d,&a0, &a0State, &a1, &a2))
        {
            Path2d *sipRes;

            sipRes = new Path2d(para_smussa(*a0,a1,a2));
            sipReleaseType(const_cast<std::vector<P2d> *>(a0),sipType_std_vector_0100P2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_para_smussaf, NULL);

    return NULL;
}


extern "C" {static PyObject *func_raccordo(PyObject *,PyObject *);}
static PyObject *func_raccordo(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        P2d * a0;
        P2d * a1;
        P2d * a2;
        double a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9d", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2, &a3))
        {
            Path2d *sipRes;

            sipRes = new Path2d(raccordo(*a0,*a1,*a2,a3));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_raccordo, NULL);

    return NULL;
}


extern "C" {static PyObject *func_dash(PyObject *,PyObject *);}
static PyObject *func_dash(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        double a1;
        double a2;
        double a3 = 0.01;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dd|d", sipType_Path2d, &a0, &a1, &a2, &a3))
        {
            std::vector<Path2d> *sipRes;

            sipRes = new std::vector<Path2d>(dash(*a0,a1,a2,a3));

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_dash, NULL);

    return NULL;
}


extern "C" {static PyObject *func_mostInternalP(PyObject *,PyObject *);}
static PyObject *func_mostInternalP(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100Path2d,&a0, &a0State))
        {
            P2d *sipRes;

            sipRes = new P2d(mostInternalP(*a0));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_mostInternalP, NULL);

    return NULL;
}


extern "C" {static PyObject *func_orient(PyObject *,PyObject *);}
static PyObject *func_orient(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        std::vector<Path2d> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100Path2d,&a0, &a0State))
        {
            std::vector<Path2d> *sipRes = 0;

#line 338 "sip/geo2dpath.sip"
    sipRes = new std::vector<Path2d>(*a0);
    orient(*sipRes);
#line 2186 "sip_geo2dcppcmodule.cpp"
            sipReleaseType(a0,sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_0100Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_orient, NULL);

    return NULL;
}


extern "C" {static PyObject *func_oddEven(PyObject *,PyObject *);}
static PyObject *func_oddEven(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::vector<Path2d> * a0;
        int a0State = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J1", sipType_std_vector_0100Path2d,&a0, &a0State))
        {
            std::vector<bool> *sipRes;

            sipRes = new std::vector<bool>(oddEven(*a0));
            sipReleaseType(const_cast<std::vector<Path2d> *>(a0),sipType_std_vector_0100Path2d,a0State);

            return sipConvertFromNewType(sipRes,sipType_std_vector_2600,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_oddEven, NULL);

    return NULL;
}


extern "C" {static PyObject *func_smooth121(PyObject *,PyObject *);}
static PyObject *func_smooth121(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        Path2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Path2d, &a0))
        {
            Path2d *sipRes = 0;

#line 330 "sip/geo2dpath.sip"
    sipRes = new Path2d(*a0);
    smooth121(*sipRes);
#line 2242 "sip_geo2dcppcmodule.cpp"

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_smooth121, NULL);

    return NULL;
}


extern "C" {static PyObject *func_bezto(PyObject *,PyObject *);}
static PyObject *func_bezto(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;
        const P2d * a2;
        const P2d * a3;
        std::vector<P2d> * a4;
        double a5 = 0.1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9J9|d", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2, sipType_P2d, &a3, &a5))
        {
            a4 = new std::vector<P2d>();

            bezto(*a0,*a1,*a2,*a3,*a4,a5);

            return sipConvertFromNewType(a4,sipType_std_vector_0100P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_bezto, NULL);

    return NULL;
}


extern "C" {static PyObject *func_refine(PyObject *,PyObject *);}
static PyObject *func_refine(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9d", sipType_Path2d, &a0, &a1))
        {
            Path2d *sipRes;

            sipRes = new Path2d(refine(*a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_refine, NULL);

    return NULL;
}


extern "C" {static PyObject *func_clipPoly(PyObject *,PyObject *);}
static PyObject *func_clipPoly(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const P2d * a1;
        const P2d * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_Path2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2))
        {
            Path2d *sipRes;

            sipRes = new Path2d(clipPoly(*a0,*a1,*a2));

            return sipConvertFromNewType(sipRes,sipType_Path2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_clipPoly, NULL);

    return NULL;
}


extern "C" {static PyObject *func_pathPathDist(PyObject *,PyObject *);}
static PyObject *func_pathPathDist(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Path2d * a0;
        const Path2d * a1;
        int a2 = 1000;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|i", sipType_Path2d, &a0, sipType_Path2d, &a1, &a2))
        {
            double sipRes = 0;
            int sipIsErr = 0;

#line 307 "sip/geo2dpath.sip"
    if (a0->len() == 0.0)
    {
        PyErr_Format(PyExc_RuntimeError, "first path has zero length");
        sipIsErr = 1;
    }
    else if (a1->len() == 0.0)
    {
        PyErr_Format(PyExc_RuntimeError, "second path has zero length");
        sipIsErr = 1;
    }
    else
        sipRes = pathPathDist(*a0, *a1, a2);
#line 2366 "sip_geo2dcppcmodule.cpp"

            if (sipIsErr)
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_pathPathDist, NULL);

    return NULL;
}


extern "C" {static PyObject *func_mirror(PyObject *,PyObject *);}
static PyObject *func_mirror(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_P2d, &a0, sipType_P2d, &a1))
        {
            X2d *sipRes = 0;
            int sipIsErr = 0;

#line 218 "sip/geo2dx.sip"
    if (dist2(*a0,*a1) < 1E-10)
    {
        sipIsErr = 1;
        PyErr_SetNone(PyExc_ZeroDivisionError);
    }
    else
        sipRes = new X2d(mirror(*a0, *a1));
#line 2404 "sip_geo2dcppcmodule.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_mirror, NULL);

    return NULL;
}


extern "C" {static PyObject *func_xform(PyObject *,PyObject *);}
static PyObject *func_xform(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;
        const P2d * a2;
        const P2d * a3;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9J9", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2, sipType_P2d, &a3))
        {
            X2d *sipRes;

            sipRes = new X2d(xform(*a0,*a1,*a2,*a3));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_xform, NULL);

    return NULL;
}


extern "C" {static PyObject *func_cScaleXY(PyObject *,PyObject *);}
static PyObject *func_cScaleXY(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        double a1;
        double a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dd", sipType_P2d, &a0, &a1, &a2))
        {
            X2d *sipRes;

            sipRes = new X2d(scale(*a0,a1,a2));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_cScaleXY, NULL);

    return NULL;
}


extern "C" {static PyObject *func_cScale(PyObject *,PyObject *);}
static PyObject *func_cScale(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9d", sipType_P2d, &a0, &a1))
        {
            X2d *sipRes;

            sipRes = new X2d(scale(*a0,a1));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_cScale, NULL);

    return NULL;
}


extern "C" {static PyObject *func_cRot(PyObject *,PyObject *);}
static PyObject *func_cRot(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9d", sipType_P2d, &a0, &a1))
        {
            X2d *sipRes;

            sipRes = new X2d(rot(*a0,a1));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_cRot, NULL);

    return NULL;
}


extern "C" {static PyObject *func_scalexy(PyObject *,PyObject *);}
static PyObject *func_scalexy(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "dd", &a0, &a1))
        {
            X2d *sipRes;

            sipRes = new X2d(scale(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_scalexy, NULL);

    return NULL;
}


extern "C" {static PyObject *func_scale(PyObject *,PyObject *);}
static PyObject *func_scale(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "d", &a0))
        {
            X2d *sipRes;

            sipRes = new X2d(scale(a0));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_scale, NULL);

    return NULL;
}


extern "C" {static PyObject *func_xlate(PyObject *,PyObject *);}
static PyObject *func_xlate(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_P2d, &a0))
        {
            X2d *sipRes;

            sipRes = new X2d(xlate(*a0));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_xlate, NULL);

    return NULL;
}


extern "C" {static PyObject *func_rot(PyObject *,PyObject *);}
static PyObject *func_rot(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "d", &a0))
        {
            X2d *sipRes;

            sipRes = new X2d(rot(a0));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_rot, NULL);

    return NULL;
}


extern "C" {static PyObject *func_xposinv(PyObject *,PyObject *);}
static PyObject *func_xposinv(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const X2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_X2d, &a0))
        {
            X2d *sipRes;

            sipRes = new X2d(xposinv(*a0));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_xposinv, NULL);

    return NULL;
}


extern "C" {static PyObject *func_inv(PyObject *,PyObject *);}
static PyObject *func_inv(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const X2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_X2d, &a0))
        {
            X2d *sipRes;

            sipRes = new X2d(inv(*a0));

            return sipConvertFromNewType(sipRes,sipType_X2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_inv, NULL);

    return NULL;
}


extern "C" {static PyObject *func_singular(PyObject *,PyObject *);}
static PyObject *func_singular(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const X2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_X2d, &a0))
        {
            bool sipRes;

            sipRes = singular(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_singular, NULL);

    return NULL;
}


extern "C" {static PyObject *func_triangleArea(PyObject *,PyObject *);}
static PyObject *func_triangleArea(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;
        const P2d * a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2))
        {
            double sipRes;

            sipRes = triangleArea(*a0,*a1,*a2);

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_triangleArea, NULL);

    return NULL;
}


extern "C" {static PyObject *func_project(PyObject *,PyObject *, PyObject *);}
static PyObject *func_project(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;
        const P2d * a2;
        bool a3 = 1;

        static const char *sipKwdList[] = {
            sipName_p,
            sipName_a,
            sipName_b,
            sipName_cap,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9|b", sipType_P2d, &a0, sipType_P2d, &a1, sipType_P2d, &a2, &a3))
        {
            P2d *sipRes;

            sipRes = new P2d(project(*a0,*a1,*a2,a3));

            return sipConvertFromNewType(sipRes,sipType_P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_project, NULL);

    return NULL;
}


extern "C" {static PyObject *func_angle(PyObject *,PyObject *);}
static PyObject *func_angle(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;
        const P2d * a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_P2d, &a0, sipType_P2d, &a1))
        {
            double sipRes = 0;
            int sipIsErr = 0;

#line 153 "sip/geo2dp.sip"
    // Questa soglia  la stessa dell'implementazione di arg() in C++.
    if (len2((*a0)) < 1E-20 || len2((*a1)) < 1E-20)
    {
        sipIsErr = 1;
        PyErr_SetString(PyExc_ValueError, "Vectors lenght is not sufficient to compute the angle");
    }
    else
    {
        sipRes = angle(*a0, *a1);
    }
#line 2790 "sip_geo2dcppcmodule.cpp"

            if (sipIsErr)
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_angle, NULL);

    return NULL;
}


extern "C" {static PyObject *func_arg(PyObject *,PyObject *);}
static PyObject *func_arg(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_P2d, &a0))
        {
            double sipRes = 0;
            int sipIsErr = 0;

#line 134 "sip/geo2dp.sip"
    // Questa soglia  la stessa dell'implementazione di dir() in C++.
    if (len2((*a0)) < 1E-20)
    {
        sipIsErr = 1;
        PyErr_SetNone(PyExc_ZeroDivisionError);
    }
    else
    {
        sipRes = arg(*a0);
    }
#line 2830 "sip_geo2dcppcmodule.cpp"

            if (sipIsErr)
                return 0;

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_arg, NULL);

    return NULL;
}


extern "C" {static PyObject *func_dir(PyObject *,PyObject *);}
static PyObject *func_dir(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_P2d, &a0))
        {
            P2d *sipRes = 0;
            int sipIsErr = 0;

#line 119 "sip/geo2dp.sip"
    // Questa soglia  la stessa dell'implementazione di dir() in C++.
    if (len2((*a0)) < 1E-20)
    {
        sipIsErr = 1;
        PyErr_SetNone(PyExc_ZeroDivisionError);
    }
    else
    {
        sipRes = new P2d(dir(*a0));
    }
#line 2870 "sip_geo2dcppcmodule.cpp"

            if (sipIsErr)
                return 0;

            return sipConvertFromNewType(sipRes,sipType_P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_dir, NULL);

    return NULL;
}


extern "C" {static PyObject *func_ortho(PyObject *,PyObject *);}
static PyObject *func_ortho(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const P2d * a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_P2d, &a0))
        {
            P2d *sipRes;

            sipRes = new P2d(ortho(*a0));

            return sipConvertFromNewType(sipRes,sipType_P2d,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_ortho, NULL);

    return NULL;
}


/*
 * This defines each type in this module.
 */
static sipTypeDef *typesTable[] = {
    &sipTypeDef__geo2dcpp_BlocksInfo.ctd_base,
    &sipTypeDef__geo2dcpp_Defect.ctd_base,
    &sipTypeDef__geo2dcpp_ISurf.ctd_base,
    &sipTypeDef__geo2dcpp_InsideTester.ctd_base,
    &sipTypeDef__geo2dcpp_MLBSplineInterpolator.ctd_base,
    &sipTypeDef__geo2dcpp_MinimumBB.ctd_base,
    &sipTypeDef__geo2dcpp_NDVector.ctd_base,
    &sipTypeDef__geo2dcpp_OrientedBB.ctd_base,
    &sipTypeDef__geo2dcpp_P2d.ctd_base,
    &sipTypeDef__geo2dcpp_Packing.ctd_base,
    &sipTypeDef__geo2dcpp_Path2d.ctd_base,
    &sipTypeDef__geo2dcpp_Placement.ctd_base,
    &sipTypeDef__geo2dcpp_Placement_Part.ctd_base,
    &sipTypeDef__geo2dcpp_Placement_Shape.ctd_base,
    &sipTypeDef__geo2dcpp_Placement_Sheet.ctd_base,
    &sipTypeDef__geo2dcpp_QualityMarker.ctd_base,
    &sipTypeDef__geo2dcpp_RuntimeError.ctd_base,
    &sipTypeDef__geo2dcpp_X2d.ctd_base,
    &sipTypeDef__geo2dcpp_bump.ctd_base,
    &sipTypeDef__geo2dcpp_bump_Bumper.ctd_base,
    &sipTypeDef__geo2dcpp_bump_PosRot.ctd_base,
    &sipTypeDef__geo2dcpp_bump_Shape.ctd_base,
    &sipTypeDef__geo2dcpp_coveringRect.ctd_base,
    &sipTypeDef__geo2dcpp_match_result.ctd_base,
    &sipTypeDef__geo2dcpp_std_map_2400_0600std_vector_0100Path2d.mtd_base,
    &sipTypeDef__geo2dcpp_std_map_1800_0600std_vector_0100Path2d.mtd_base,
    &sipTypeDef__geo2dcpp_std_string.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100Defect.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0101OrientedBB.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100P2d.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100Packing.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100Path2d.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100QualityMarker.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_2600.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100coveringRect.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_2400.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_1800.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0100match_result.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0600std_vector_0100P2d.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0600std_vector_0100Path2d.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_0600std_vector_2400.mtd_base,
    &sipTypeDef__geo2dcpp_std_vector_1300.mtd_base,
    &sipTypeDef__geo2dcpp_std_wstring.mtd_base,
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI__geo2dcpp = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_geo2d__geo2dcpp,
    0,
    -1,
    sipStrings__geo2dcpp,
    NULL,
    NULL,
    43,
    typesTable,
    NULL,
    0,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI__geo2dcpp;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit__geo2dcpp
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        init_geo2dcpp
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_MLNAME_CAST(sipName_NDVect), func_NDVect, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_blocks), func_blocks, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_vecpath_test), func_vecpath_test, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_vecvecpath_test), func_vecvecpath_test, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_mapvecpath_test), func_mapvecpath_test, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_get_weights), func_get_weights, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_uniform_sampling), func_uniform_sampling, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_fixed_sampling), func_fixed_sampling, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_vecpathOverVecpath), func_vecpathOverVecpath, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_vecpathOverPath), func_vecpathOverPath, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_pathOverPath), func_pathOverPath, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_points_matching), func_points_matching, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_rects_cover), func_rects_cover, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_pack), func_pack, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_unione_path), func_unione_path, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_complexSplineXC), func_complexSplineXC, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_oldSplineX), func_oldSplineX, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_xsarea), func_xsarea, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_areas), func_areas, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_unionAreaValue), func_unionAreaValue, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_unionAreaPaths), func_unionAreaPaths, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_sarea), func_sarea, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_area), func_area, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_self_intersections), func_self_intersections, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_intersections), func_intersections, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_intersect), func_intersect, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_inside_equal), func_inside_equal, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_inside), func_inside, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_calcPara), func_calcPara, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_ispline), func_ispline, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_hermite), func_hermite, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_splineX), func_splineX, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_triangulate), func_triangulate, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_unisci), func_unisci, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_quasi_convex_hull), func_quasi_convex_hull, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_regularize), func_regularize, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_convex_hull_presorted), func_convex_hull_presorted, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_convex_hull), func_convex_hull, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_simplify_contained), func_simplify_contained, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_simplifyf), func_simplifyf, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_enlarge_area), func_enlarge_area, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_nd), func_nd, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_offsetf), func_offsetf, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_paraf), func_paraf, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_para_smussaf), func_para_smussaf, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_raccordo), func_raccordo, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_dash), func_dash, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_mostInternalP), func_mostInternalP, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_orient), func_orient, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_oddEven), func_oddEven, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_smooth121), func_smooth121, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_bezto), func_bezto, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_refine), func_refine, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_clipPoly), func_clipPoly, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_pathPathDist), func_pathPathDist, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_mirror), func_mirror, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_xform), func_xform, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_cScaleXY), func_cScaleXY, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_cScale), func_cScale, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_cRot), func_cRot, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_scalexy), func_scalexy, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_scale), func_scale, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_xlate), func_xlate, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_rot), func_rot, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_xposinv), func_xposinv, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_inv), func_inv, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_singular), func_singular, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_triangleArea), func_triangleArea, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_project), (PyCFunction)func_project, METH_VARARGS|METH_KEYWORDS, NULL},
        {SIP_MLNAME_CAST(sipName_angle), func_angle, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_arg), func_arg, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_dir), func_dir, METH_VARARGS, NULL},
        {SIP_MLNAME_CAST(sipName_ortho), func_ortho, METH_VARARGS, NULL},
        {0, 0, 0, 0}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "geo2d._geo2dcpp",
        NULL,
        -1,
        sip_methods,
        NULL,
        NULL,
        NULL,
        NULL
    };
#endif

    PyObject *sipModule, *sipModuleDict;
#if PY_VERSION_HEX < 0x03010000
    PyObject *sip_sipmod, *sip_capiobj;
#endif

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_geo2d__geo2dcpp, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_geo2d__geo2dcpp), sip_methods);
#endif

    if (sipModule == NULL)
        SIP_MODULE_RETURN(NULL);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Get the SIP module's API. */
#if PY_VERSION_HEX >= 0x03010000

    sipAPI__geo2dcpp = reinterpret_cast<const sipAPIDef *>(PyCapsule_Import("sip._C_API", 0));

    if (sipAPI__geo2dcpp == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

#else

#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule("sip");
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>("sip"));
#endif

    if (sip_sipmod == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");

    if (sip_capiobj == NULL || !PyCObject_Check(sip_capiobj))
    {
        Py_DECREF(sip_sipmod);
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sipAPI__geo2dcpp = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));

#endif

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI__geo2dcpp,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
#if PY_VERSION_HEX < 0x03010000
        Py_DECREF(sip_sipmod);
#endif
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }
    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI__geo2dcpp,sipModuleDict) < 0)
    {
#if PY_VERSION_HEX < 0x03010000
        Py_DECREF(sip_sipmod);
#endif
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }
#line 118 "sip/geo2dpath.sip"
    if (PyType_Ready(&ProjectResult_Type) < 0)
        return;
    PyModule_AddObject(sipModule, "ProjectResult", (PyObject*)&ProjectResult_Type);
#line 3185 "sip_geo2dcppcmodule.cpp"

    SIP_MODULE_RETURN(sipModule);
}
